using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Security;
using System.Text;
using System.Threading.Tasks;
using Inedo.Diagnostics;
using Inedo.Documentation;
using Inedo.Extensibility.VulnerabilitySources;
using Inedo.Serialization;
using Newtonsoft.Json;

namespace Inedo.Extension.Clair.VulnerabilitySources
{
    [DisplayName("Clair Index")]
    [Description("Automatically sends Docker Container Layers to the Clair V1 API for static analysis of vulnerabilities. This requires Web.BaseUrl to be set in your Advanced Settings.")]
    public sealed class ClairVulnerabilitySource : VulnerabilitySource
    {
        [Persistent]
        [DisplayName("Clair API URL")]
        [PlaceholderText("http://localhost:6060/")]
        public string ApiUrl { get; set; }
        [DisplayName("API Authorization Header Value")]
        [Persistent(Encrypted = true)]
        public SecureString AuthenticationHeader { get; set; }

        public override async Task<IEnumerable<VulnerabilityInfo>> GetVulnerabilitiesAsync(IVulnerabilitySourceContext context)
        {
            var serializer = new JsonSerializer();
            var layersApi = ApiUrl.Trim('/') + "/v1/layers";
            var vulnerabilitesApiUrl = ApiUrl.Trim('/') + "/v1/layers/{0}?features&vulnerabilities";

            

            var vulnerabilityInfos = new List<VulnerabilityInfo>();

            foreach (var blob in context.Blobs.Where(b => !b.MediaType.EndsWith("json", StringComparison.OrdinalIgnoreCase)))
            {
                var postRequest = this.CreatePostWebRequest(layersApi);
                var response = await this.PushLayerToClair(serializer, postRequest, blob);
                if(response != null)
                {
                    var vResponse = await this.GetVulnerabilitesFromClair(serializer, vulnerabilitesApiUrl, blob, response);
                    if(vResponse?.Layer?.Features?.Any(f => f?.Vulnerabilities?.Any(v => v != null) ?? false) != null)
                    {
                        var vulnerableFeatures = vResponse.Layer.Features.Where(f => f.Vulnerabilities?.Any() ?? false);
                        foreach(var vulnerableFeature in vulnerableFeatures)
                        {
                            foreach(var vulnerability in vulnerableFeature.Vulnerabilities)
                            {
                                vulnerabilityInfos.Add(new ClairVulnerabilityInfo(this.BuildId(vulnerableFeature), blob.FeedType, blob.Digest, vulnerability.Name, this.BuildDescription(vulnerableFeature, vulnerability)));
                            }
                        }
                    }
                }
            }

            return vulnerabilityInfos;
        }

        private string BuildDescription(ClairVulnerabiltyResponse.ClairFeature feature, ClairVulnerabiltyResponse.ClairVulnerability vulnerability)
        {
            var builder = new StringBuilder();

            builder.AppendLine(vulnerability.Description);
            builder.AppendLine();
            builder.AppendLine($"Severity: {vulnerability.Severity}");
            builder.AppendLine($"More Information: {vulnerability.Link}");
            builder.AppendLine();
            builder.AppendLine($"Namespace: {feature.NamespaceName}");
            builder.AppendLine($"Feature: {feature.Name}");
            builder.AppendLine($"Feature Version: {feature.Version}");
            builder.AppendLine($"Fixed By Version: {vulnerability.FixedBy}");

            return builder.ToString();
        }

        private string BuildId(ClairVulnerabiltyResponse.ClairFeature feature)
        {
            return $"{feature.Name}:{feature.Version}";
        }

        private async Task<ClairVulnerabiltyResponse> GetVulnerabilitesFromClair(JsonSerializer serializer, string vulnerabilitesApiUrl, IVulnerabilityDockerBlob blob, ClairPostResponse response)
        {
            try
            {
                var vRequest = this.CreateGetWebRequest(string.Format(vulnerabilitesApiUrl, response.Layer.Name));
                HttpWebResponse vResponse = (HttpWebResponse)await vRequest.GetResponseAsync();
                if (vResponse.StatusCode == HttpStatusCode.OK || vResponse.StatusCode == HttpStatusCode.Created)
                {
                    using (var responseStream = vResponse.GetResponseStream())
                    using (var textReader = new StreamReader(responseStream, InedoLib.UTF8Encoding))
                    using (var jsonTextReader = new JsonTextReader(textReader))
                    {
                        var vulnerabilities = serializer.Deserialize<ClairVulnerabiltyResponse>(jsonTextReader);
                        this.LogDebug($"Layer {blob.Digest} pulled vulnerabilities from clair", JsonConvert.SerializeObject(vulnerabilities));
                        return vulnerabilities;
                    }
                }
                else if ((int)vResponse.StatusCode == 422)
                {
                    this.LogInformation($"Clair could not process layer {blob.Digest}, request was valid");
                    return null;
                }
                else
                {
                    this.LogWarning($"Clair returned error {vResponse.StatusCode} for layer {blob.Digest}");
                    return null;
                }
            }
            catch (WebException webEx)
            {
                var webResponse = (HttpWebResponse)webEx.Response;
                if ((int)webResponse.StatusCode == 422)
                {
                    this.LogInformation($"Clair could not process layer {blob.Digest}, request was valid.", webEx.ToString());
                    return null;
                }
                else
                {
                    this.LogWarning($"Clair returned error {webResponse.StatusCode} for layer {blob.Digest}.", webEx.ToString());
                    return null;
                }
            }
            catch (Exception ex)
            {
                this.LogError(ex.Message, ex.ToString());
                return null;
            }
        }

        private async Task<ClairPostResponse> PushLayerToClair(JsonSerializer serializer, WebRequest request, IVulnerabilityDockerBlob blob)
        {
            var clairRequest = new ClairPostRequest();
            clairRequest.Layer = new ClairPostRequest.ClairLayer
            {
                Format = "Docker",
                Name = blob.Digest,
                Path = blob.DownloadUrl,
                Headers = new ClairPostRequest.ClairHeaders()
            };


            if (AuthenticationHeader != null)
            {
                clairRequest.Layer.Headers.Autorization = AH.Unprotect(AuthenticationHeader);
            }
            var requestStream = await request.GetRequestStreamAsync().ConfigureAwait(false);
            using (var textWriter = new StreamWriter(requestStream, InedoLib.UTF8Encoding, 16, true))
            {
                serializer.Serialize(textWriter, clairRequest);
                //request.ContentLength = stream.Length;
                //stream.Position = 0;
                
                textWriter.Flush();
                requestStream.Close();
            }
            try
            {
                var response = (HttpWebResponse)(await request.GetResponseAsync().ConfigureAwait(false));

                if (response.StatusCode == HttpStatusCode.OK || response.StatusCode == HttpStatusCode.Created)
                {
                    using (var responseStream = response.GetResponseStream())
                    using (var textReader = new StreamReader(responseStream, InedoLib.UTF8Encoding))
                    using (var jsonTextReader = new JsonTextReader(textReader))
                    {
                        var scan = serializer.Deserialize<ClairPostResponse>(jsonTextReader);
                        this.LogDebug($"Layer {blob.Digest} pushed to clair", JsonConvert.SerializeObject(scan));
                        return scan;
                    }
                }
                else if ((int)response.StatusCode == 422)
                {
                    this.LogInformation($"Clair could not process layer {blob.Digest}, request was valid");
                    return null;
                }
                else
                {
                    this.LogWarning($"Clair returned error {response.StatusCode} for layer {blob.Digest}");
                    return null;
                }
            }
            catch(WebException webEx)
            {
                var response = (HttpWebResponse)webEx.Response;
                if ((int)response.StatusCode == 422)
                {
                    this.LogInformation($"Clair could not process layer {blob.Digest}, request was valid.", webEx.ToString());
                    return null;
                }
                else
                {
                    this.LogWarning($"Clair returned error {response.StatusCode} for layer {blob.Digest}.", webEx.ToString());
                    return null;
                }
            }
            catch(Exception ex)
            {
                this.LogError(ex.Message, ex.ToString());
                return null;
            }
        }

        private WebRequest CreatePostWebRequest(string url)
        {
            var request = WebRequest.Create(url);
            request.Method = "POST";
            request.ContentType = "application/json";

            return request;
        }

        private WebRequest CreateGetWebRequest(string url)
        {
            var request = WebRequest.Create(url);
            request.Method = "GET";
            request.ContentType = "application/json";

            return request;
        }
    }
}
